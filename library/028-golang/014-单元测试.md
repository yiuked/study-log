
```
usage: go test [build/test flags] [packages] [build/test flags & test binary flags]
[build/test flags]
  -v 显示每一个测试函数的结果，默认只显示最终的测试结果
```


GO 语言内建了单元测试（Unit Test）框架。这是为了从语言层面规范写 UT 的方式。GO 语言的命名规则会将以 _test.go 结尾的 go 文件视作单元测试代码。

当我们用 go build 构建可执行程序时，这些 _test.go 文件被排除在构建范围之外。而当我们用 go test 来进行单元测试时，这些 _test.go 文件则会参与构建，且还会提供一个默认的 TestMain 函数作为 UT 的起始入口


为了让 GO 语言的测试框架能够自动发现我们所有的测试用例，测试函数的签名也要遵循其特定的规则：

函数名必须以 Test 开头，后面通常是待测方法的函数名
参数必须是 *testing.T，它提供了 Error，Fatal 等方法用来报错和终止测试的运行


Go语言中的单元测试，分为【测试】和【基准性能测试】，【测试】就是看一个函数或方法，写的是否正确，能否得到预期的运行结果；【基准性能测试】就是指，测试一个函数或者方法的性能或效率，比如一个排序算法，排列一个包含1000万个元素的随机数组，总耗时是多少，内存开销是多少。

## *_test.go文件必须放在被测试文件同级目录，否则无法被覆盖测试抓取

## 集成测试
## 单元测试

http://goconvey.co/

https://blog.csdn.net/qq_41431406/article/details/100914477


main包里定义的全局变量别的包是无法引用的。

通常选择放在global包或其他自定义的包中，然后让其他包来引用
```
go test -c -covermode=count -coverpkg ./...
```

## 参数

* 参数`-v`可用于打印每个测试函数的名字和运行时间：
```
$ go test -v
=== RUN TestPalindrome
--- PASS: TestPalindrome (0.00s)
=== RUN TestNonPalindrome
--- PASS: TestNonPalindrome (0.00s)
=== RUN TestFrenchPalindrome
--- FAIL: TestFrenchPalindrome (0.00s)
    word_test.go:28: IsPalindrome("été") = false
=== RUN TestCanalPalindrome
--- FAIL: TestCanalPalindrome (0.00s)
    word_test.go:35: IsPalindrome("A man, a plan, a canal: Panama") = false
FAIL
exit status 1
FAIL    gopl.io/ch11/word1  0.017s
```

* 参数`-run`对应一个正则表达式，只有测试函数名被它正确匹配的测试函数才会被`go test`测试命令运行：
```
$ go test -v -run="French|Canal"
=== RUN TestFrenchPalindrome
--- FAIL: TestFrenchPalindrome (0.00s)
    word_test.go:28: IsPalindrome("été") = false
=== RUN TestCanalPalindrome
--- FAIL: TestCanalPalindrome (0.00s)
    word_test.go:35: IsPalindrome("A man, a plan, a canal: Panama") = false
FAIL
exit status 1
FAIL    gopl.io/ch11/word1  0.014s
```

前言
前面的章节我们分析了每种测试的数据结构及其实现原理，本节我们看一下go test的执行机制。

Go 有多个命令行工具，go test只是其中一个。go test命令的函数入口在src\cmd\go\internal\test\test.go:runTest()，这个函数就是go test的大脑。

runTest()
runTest()函数场景如下：

func runTest(cmd *base.Command, args []string)
GO 命令行工具的实现中，都遵循这种函数声明，其中args即命令行输入的全部参数。

runTest首先会分析所有需要测试的包，为每个待测包生成一个二进制文件，然后执行。

两种运行模式
go test运行时，跟据是否指定package分为两种模式，即本地目录模式和包列表模式。

本地目录模式
当执行测试并没有指定package时，即以本地目录模式运行，例如使用"go test"或者"go test -v"来启动测试。
本地目录模式下，go test编译当前目录的源码文件和测试文件，并生成一个二进制文件，最后执行并打印结果。

包列表模式
当执行测试并显式指定package时，即以包列表模式运行，例如使用"go test math"来启动测试。
包列表模式下，go test为每个包生成一个测试二进制文件，并分别执行它。 包列表模式是在Go 1.10版本才引入的，它会把每个包的测试结果写入到本地临时文件中做为缓存，下次执行时会直接从缓存中读取测试结果，以便节省测试时间。
```
C:\Users\apple>go test gorm
can't load package: package gorm: cannot find package "gorm" in any of:
        c:\go\src\gorm (from $GOROOT)
        C:\Users\apple\go\src\gorm (from $GOPATH)
```
可以看到，包列表模式，先会从`$GOROOT`寻找包名，当`$GOROOT`不存在时，会向`$GOPATH`中去寻找

缓存机制
当满足一定的条件，测试的缓存是自动启用的，也可以显式的关闭缓存。

测试结果缓存
如果一次测试中，其参数全部来自"可缓存参数"集合，那么本次测试结果将被缓存。

可缓存参数集合如下：
```
-cpu
-list
-parallel
-run
-short
-v
```
需要注意的是，测试参数必须全部来自这个集合，其结果才会被缓存，没有参数或包含任一此集合之外的参数，结果都不会缓存。



http://shouce.jb51.net/gopl-zh/ch11/ch11-02.html
