## SQL对比聚合框架

| SQL      | 聚合框架操作            |
| -------- | ----------------------- |
| select * | $project，$group函数    |
| from     | db.collection.aggregate |
| join     | $unwind                 |
| where    | $match                  |
| group    | $group                  |
| having   | $match                  |
| limit    | $limit,$skip            |
| order    | $sort                   |



- group

```
db.books.aggregate([{
	'$group':{'_id':'$bookcover','cnt':{'$sum':1}}
}])
```

- 一对多联表查询

```
db.countryCode.aggregate([
{ $lookup: {from: "countryCodeLookup", localField: "code", foreignField: "code", as: "countryName"} },
{ $project: {"code":1, "countryName.name":1, "_id":0} },
{ $match:{"code":1.0}}
])
```

> 上面通过 $lookup 操作符连接两个集合，其中 $project 会过滤属性，$match 作为条件匹配对应的结果

- 一对一联表查询

```
db.countryCode.aggregate([
{ $lookup: {from: "countryCodeLookup", localField: "code", foreignField: "code", as: "countryName"} },
{ $project: {"code":1, "countryName.name":1, "_id":0} },
{ $unwind: "$countryName"},
{ $match:{"code":1.0}}
])
```

- 分页联表查询

```
db.bookshelf.aggregate(
{ $match: {"user_id":0，"book_state":1} }, // 搜寻条件
{ $sort: {"last_read_at":1} }, // 排序，1正序，-1倒序
{ $skip: 5 }, // 跳过5条
{ $limit: 10 }, // 取10条件，$limit需要放在$skip后面
{
   $lookup:
     {
       from: "books", // 要关联查询的表
       localField: "book_id", // 主表用来关联从表的字段
       foreignField: "_id", // 从表用来响应关联的字段
       as: "book" // 将结果重命名为
     }
},
{ $project: {"_id":0,"book_id":0} }, // 需要过虑的字段
{ $unwind: "$book"}, // 将关联查询的结果转为文档，不加这行关联查询返回的是数组
)
```





>bson.D 与 bson.M 用于查找查询
>
>这个特定问题与将 mongodb 与 golang 包一起使用有关mongo-driver，但我认为这适用于大多数与 mongodb 的接口。
>
>当Find用于从集合中查询某些数据时，我们可以同时使用bson.M- 和bson.D- 类型来指定此查找的过滤器。
>
>bson.D如果元素的顺序很重要，bson.M则应根据文档使用，否则应使用。
>
>D 是 BSON 文档的有序表示。当元素的顺序很重要时，应该使用这种类型，例如 MongoDB 命令文档。如果元素的顺序无关紧要，则应使用 M 代替。
>
>现在我的问题是使用这些结构中的任何一个，即有序与无序，结构是否会对 mongo 查询优化器生成的查询计划产生影响。
>
>在经典的 SQL 数据库中，顺序通常无关紧要，因为优化器足够聪明，可以使用汇总统计信息、索引等来确定首先执行哪些查询。
>
>我是否可以假设这里也是这种情况，或者使用有序结构来查询我的集合是否会以某种方式干扰这一点/是否使用类似于使用优化器提示的有序结构工作？如果有一些干扰，这是否受到要搜索的字段是否被索引的影响？
>
>icza..  8
>
>您可以使用bson.Mfor 过滤器，它通常会导致更短和更清晰的过滤器声明，字段的顺序无关紧要，MongoDB 服务器足够智能，无论使用的顺序如何，都可以找到匹配的索引。例如，如果您有一个包含字段A和的复合索引，则首先B使用bson.D过滤器列表不会阻止服务器使用现有索引。因此，在这种情况下，您可以使用和，这无关紧要。BAbson.Mbson.D
>
>例如，当您指定排序字段时，顺序很重要。如果您先按字段排序，A然后按字段排序B，这可能与按B先排序再按排序完全不同A。因此，当您指定具有多个字段的排序文档时，您绝对应该使用bson.D.
>
>例如，当您插入新文档时，顺序也可能很重要。如果您使用 abson.M作为文档，则不能保证所有文档中的字段顺序都相同。当您使用 时bson.D，保存的文档中的顺序将与您在 中列出字段时的顺序相匹配bson.D。
