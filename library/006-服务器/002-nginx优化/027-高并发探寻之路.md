## 高并发探寻之路

##### 系统层

```
fs.file-max = 40000500
fs.nr_open = 40000500
```



```
// 单个进程能够打开的最大文件句柄数量，缺省值是1024
ulimit -n 20000500
```

root用户可以任意调高资源限额，整个系统的总体限制是`/proc/sys/fs/file-max`里的数字,root用户的进程依然会受到**ulimit** **-n**的数字的限制，但root用户可以在程序运行之前，调用**ulimit** **-n**命令来修改这个限制（有些init_scripts就是这样做的），也可以在进程内部通过set_limit系统调用来提高上限。相比之下，普通用户也可通过这两种方式修改限制，但有上限即hard limit（默认一般是4096），而root可以无限提高这个限制。

##### nginx层

```
// 同时进行工作的**进程**数量，建议与系统CPU核数一致。
worker_processes auto;
// 是一个工作进程最多可以打开多少个文件句柄。
worker_rlimit_nofile 65535;
events {
	user epoll;
	worker_connections 2048000;
}
```

> **worker_processes**
>
> 工作进程是单线程进程。 如果Nginx正在进行CPU密集型工作（如SSL或gzipping），并且您有2个或更多CPU /核心，则可以将worker_processes设置为等于CPU或核心数。 如果您提供大量静态文件并且文件的总大小大于可用内存，那么您可以增加worker_processes以充分利用磁盘带宽。默认值为等于CPU或核心数。
>
> **worker_connections**
>
>  main部分中的worker_connections和worker_processes允许您计算可以处理的最大客户端： 
>
> ```
> max clients = worker_processes * worker_connections
> ```



既然**ulimit** **-n**默认是1024,为何很多进程打开的文件句柄数还会超过1024达到好几万呢？



### 监控方法

#### 命令形式

统计 TCP连接数 命令：

```
netstat -an |grep ‘ESTABLISHED’ |grep ‘tcp’ |wc -l
```

> LISTEN：侦听来自远方的TCP端口的连接请求；
> SYN-SENT：在发送连接请求后等待匹配的连接请求；
> SYN-RECEIVED：在收到和发送一个连接请求后等待对方对连接请求的确认；
> ESTABLISHED：代表一个打开的连接，我们常用此作为并发连接数；
> FIN-WAIT-1：等待远程TCP连接中断请求，或先前的连接中断请求的确认；
> FIN-WAIT-2：从远程TCP等待连接中断请求；
> CLOSE-WAIT：等待从本地用户发来的连接中断请求；
> CLOSING：等待远程TCP对连接中断的确认；
> LAST-ACK：等待原来发向远程TCP的连接中断的确认；
> TIME-WAIT：等待足够的时间以确保远程TCP连接收到中断请求的确认；
> CLOSED：没有任何连接状态；

#### WEB形式

在nginx配置文件中加入

```
location /ngx_status {
	stub_status on;
	access_log off;
	allow 127.0.0.1;
	deny all;
}
```

>```
>Active connections: 2 
>server accepts handled requests
> 10223 10223 10266 
>Reading: 0 Writing: 1 Waiting: 1 
>```